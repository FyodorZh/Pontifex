using System;

namespace Shared.Utils
{
    /// <summary>
    /// Состояние в котором может находится WorkStory в процессе своей жизни
    /// </summary>
    public enum WorkstoryState
    {
        /// <summary>
        /// Нормальное состояние WorkStory от начала её жизни до момента выполения всех заадч.
        /// </summary>
        InProgress,

        /// <summary>
        /// Состояние в которое переходит WorkStory после успешного завершения всех своих задач. Определяется IWorkstory.IsFinished.
        /// </summary>
        Done,

        /// <summary>
        /// WorkStory переходит в это состояние если IWorkstory.Tick() выполняется дольше чем IWorkstory.MaxTickTime.
        /// При этом выполняемый тик жёстко прерывается с помощью Thread.Abort(), внутреннее состояние WorkStory более не может считаться консистентным.
        /// WorkStory считается завершённой с ошибкой.
        /// </summary>
        Hung,

        /// <summary>
        /// WorkStory переходит в это состояние если IWorkstory.Tick() выбросил необработанное им исключение.
        /// Корректность внутреннего состояния WorkStory зависит от конкретной реализации.
        /// WorkStory считается завершённой с ошибкой.
        /// </summary>
        Crashed,
    }

    /// <summary>
    /// Инкапсулирует конкретную реализацию Workstory.
    /// WorkStory это длительный многоэтапный вычислительные процесс состояший из последовательности вызовов IWorkstory.Tick().
    /// Определение количества шагов, таймаутов между ними и оценка максимального временного бюджета их выполнения лежит на самой WorkStory.
    /// До тех пор пока WorkStory.IsFinished != TRUE WorkStory будет получать вызов Tick() в момент времен NextTickTime,
    /// Tick() обещает затратить на своё выполнение не более MaxTickTime времени.
    /// IWorkstory в процессе работы должен толерантно относиться к возможной смене рабочего потока выполняющего Tick()
    /// </summary>
    public interface IWorkStory
    {
        /// <summary>
        /// Обязан быть полностью тредобезопасным!
        /// Возвращает TRUE еслт WorkStory более не хочет получать Tick()
        /// </summary>
        bool IsFinished { get; }

        /// <summary>
        /// Обязан быть полностью тредобезопасным!
        /// Определяет момент времени в который Workstory желает получить управление в Tick()
        /// </summary>
        DateTime NextTickTime { get; }

        /// <summary>
        /// Обязан быть полностью тредобезопасным.
        /// Определяет временной бюджет в который должен вписаться очередной Tick()
        /// В случае превышения этого лимита WorkLoad считается зависшим и будет жёстко прерван, с возможным разрушением консистентности внутреннего состояния.
        /// </summary>
        DeltaTime MaxTickTime { get; }

        /// <summary>
        /// Гарантируется отсутсвие вызовов этого метода внахлёст. Во всех остальных вопросах Tick() обязан быть тредобезопасным.
        /// В случае превышения временного бюжета на выполнение, который равен MaxTickTime получет прерывание через механизм Thread.Abort() со всеми последствиями.
        /// </summary>
        void Tick(DateTime now);
    }
}